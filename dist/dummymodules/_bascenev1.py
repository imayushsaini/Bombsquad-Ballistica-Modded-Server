# Released under the MIT License. See LICENSE for details.
#
"""A dummy stub module for the real _bascenev1.

The real _bascenev1 is a compiled extension module and only available
in the live engine. This dummy-module allows Pylint/Mypy/etc. to
function reasonably well outside of that environment.

Make sure this file is never included in dirs seen by the engine!

In the future perhaps this can be a stub (.pyi) file, but we will need
to make sure that it works with all our tools (mypy, pylint, pycharm).

NOTE: This file was autogenerated by batools.dummymodule; do not edit by hand.
"""

# I'm sorry Pylint. I know this file saddens you. Be strong.
# pylint: disable=useless-suppression
# pylint: disable=unnecessary-pass
# pylint: disable=use-dict-literal
# pylint: disable=use-list-literal
# pylint: disable=unused-argument
# pylint: disable=missing-docstring
# pylint: disable=too-many-locals
# pylint: disable=redefined-builtin
# pylint: disable=too-many-lines
# pylint: disable=redefined-outer-name
# pylint: disable=invalid-name
# pylint: disable=no-value-for-parameter

from __future__ import annotations

from typing import TYPE_CHECKING, overload, TypeVar

if TYPE_CHECKING:
    from typing import Any, Callable, Literal, Sequence
    import babase
    import bascenev1


_T = TypeVar('_T')


def _uninferrable() -> Any:
    """Get an "Any" in mypy and "uninferrable" in Pylint."""
    # pylint: disable=undefined-variable
    return _not_a_real_variable  # type: ignore


class ActivityData:
    """(internal)"""

    def context(self) -> bascenev1.ContextRef:
        """Return a context-ref pointing to the activity."""
        import bascenev1  # pylint: disable=cyclic-import

        return bascenev1.ContextRef()

    def exists(self) -> bool:
        """Returns whether the ActivityData still exists.
        Most functionality will fail on a nonexistent instance.
        """
        return bool()

    def expire(self) -> None:
        """Expires the internal data for the activity"""
        return None

    def make_foreground(self) -> None:
        """Sets this activity as the foreground one in its session."""
        return None

    def start(self) -> None:
        """Begins the activity running"""
        return None


# noinspection PyShadowingNames
class BaseTimer:
    """Timers are used to run code at later points in time.

    Category: **General Utility Classes**

    This class encapsulates a base-time timer in the current scene
    context.
    The underlying timer will be destroyed when either this object is
    no longer referenced or when its Context (Activity, etc.) dies. If you
    do not want to worry about keeping a reference to your timer around,
    you should use the bascenev1.basetimer() function instead.

    ###### time (float)
    > Length of time in seconds that the timer will wait
    before firing.

    ###### call (Callable[[], Any])
    > A callable Python object. Remember that the timer will retain a
    strong reference to the callable for as long as it exists, so you
    may want to look into concepts such as babase.WeakCall if that is not
    desired.

    ###### repeat (bool)
    > If True, the timer will fire repeatedly, with each successive
    firing having the same delay as the first.

    ##### Example

    Use a BaseTimer object to print repeatedly for a few seconds:
    >>> import bascenev1 as bs
    ... def say_it():
    ...     bs.screenmessage('BADGER!')
    ... def stop_saying_it():
    ...     global g_timer
    ...     g_timer = None
    ...     bs.screenmessage('MUSHROOM MUSHROOM!')
    ... # Create our timer; it will run as long as we have the self.t ref.
    ... g_timer = bs.BaseTimer(0.3, say_it, repeat=True)
    ... # Now fire off a one-shot timer to kill it.
    ... bs.basetimer(3.89, stop_saying_it)
    """

    def __init__(
        self, time: float, call: Callable[[], Any], repeat: bool = False
    ) -> None:
        pass


class CollisionMesh:
    """A reference to a collision-mesh.

    Category: **Asset Classes**

    Use bascenev1.getcollisionmesh() to instantiate one.
    """

    pass


class Data:
    """A reference to a data object.

    Category: **Asset Classes**

    Use bascenev1.getdata() to instantiate one.
    """

    def getvalue(self) -> Any:
        """Return the data object's value.

        This can consist of anything representable by json (dicts, lists,
        numbers, bools, None, etc).
        Note that this call will block if the data has not yet been loaded,
        so it can be beneficial to plan a short bit of time between when
        the data object is requested and when it's value is accessed.
        """
        return _uninferrable()


class InputDevice:
    """An input-device such as a gamepad, touchscreen, or keyboard.

    Category: **Gameplay Classes**
    """

    allows_configuring: bool
    """Whether the input-device can be configured."""

    has_meaningful_button_names: bool
    """Whether button names returned by this instance match labels
       on the actual device. (Can be used to determine whether to show
       them in controls-overlays, etc.)."""

    player: bascenev1.SessionPlayer | None
    """The player associated with this input device."""

    client_id: int
    """The numeric client-id this device is associated with.
       This is only meaningful for remote client inputs; for
       all local devices this will be -1."""

    name: str
    """The name of the device."""

    unique_identifier: str
    """A string that can be used to persistently identify the device,
       even among other devices of the same type. Used for saving
       prefs, etc."""

    id: int
    """The unique numeric id of this device."""

    instance_number: int
    """The number of this device among devices of the same type."""

    is_controller_app: bool
    """Whether this input-device represents a locally-connected
       controller-app."""

    is_remote_client: bool
    """Whether this input-device represents a remotely-connected
       client."""

    def __bool__(self) -> bool:
        """Support for bool evaluation."""
        return bool(True)  # Slight obfuscation.

    def detach_from_player(self) -> None:
        """Detach the device from any player it is controlling.

        This applies both to local players and remote players.
        """
        return None

    def exists(self) -> bool:
        """Return whether the underlying device for this object is
        still present.
        """
        return bool()

    def get_axis_name(self, axis_id: int) -> str:
        """Given an axis ID, return the name of the axis on this device.

        Can return an empty string if the value is not meaningful to humans.
        """
        return str()

    def get_button_name(self, button_id: int) -> babase.Lstr:
        """Given a button ID, return a human-readable name for that key/button.

        Can return an empty string if the value is not meaningful to humans.
        """
        import babase  # pylint: disable=cyclic-import

        return babase.Lstr(value='')

    def get_default_player_name(self) -> str:
        """(internal)

        Returns the default player name for this device. (used for the 'random'
        profile)
        """
        return str()

    def get_player_profiles(self) -> dict:
        """(internal)"""
        return dict()

    def get_v1_account_name(self, full: bool) -> str:
        """Returns the account name associated with this device.

        (can be used to get account names for remote players)
        """
        return str()

    def is_attached_to_player(self) -> bool:
        """Return whether this device is controlling a player of some sort.

        This can mean either a local player or a remote player.
        """
        return bool()


class Material:
    """An entity applied to game objects to modify collision behavior.

    Category: **Gameplay Classes**

    A material can affect physical characteristics, generate sounds,
    or trigger callback functions when collisions occur.

    Materials are applied to 'parts', which are groups of one or more
    rigid bodies created as part of a bascenev1.Node. Nodes can have any
    number of parts, each with its own set of materials. Generally
    materials are specified as array attributes on the Node. The `spaz`
    node, for example, has various attributes such as `materials`,
    `roller_materials`, and `punch_materials`, which correspond
    to the various parts it creates.

    Use bascenev1.Material to instantiate a blank material, and then use
    its babase.Material.add_actions() method to define what the material
    does.
    """

    def __init__(self, label: str | None = None) -> None:
        pass

    label: str
    """A label for the material; only used for debugging."""

    def add_actions(
        self, actions: tuple, conditions: tuple | None = None
    ) -> None:
        """Add one or more actions to the material, optionally with conditions.

        ##### Conditions
        Conditions are provided as tuples which can be combined
        to form boolean logic. A single condition might look like
        `('condition_name', cond_arg)`, or a more complex nested one
        might look like `(('some_condition', cond_arg), 'or',
        ('another_condition', cond2_arg))`.

        `'and'`, `'or'`, and `'xor'` are available to chain
        together 2 conditions, as seen above.

        ##### Available Conditions
        ###### `('they_have_material', material)`
        > Does the part we're hitting have a given bascenev1.Material?

        ###### `('they_dont_have_material', material)`
        > Does the part we're hitting not have a given bascenev1.Material?

        ###### `('eval_colliding')`
        > Is `'collide'` true at this point
        in material evaluation? (see the `modify_part_collision` action)

        ###### `('eval_not_colliding')`
        > Is 'collide' false at this point
        in material evaluation? (see the `modify_part_collision` action)

        ###### `('we_are_younger_than', age)`
        > Is our part younger than `age` (in milliseconds)?

        ###### `('we_are_older_than', age)`
        > Is our part older than `age` (in milliseconds)?

        ###### `('they_are_younger_than', age)`
        > Is the part we're hitting younger than `age` (in milliseconds)?

        ###### `('they_are_older_than', age)`
        > Is the part we're hitting older than `age` (in milliseconds)?

        ###### `('they_are_same_node_as_us')`
        > Does the part we're hitting belong to the same bascenev1.Node as us?

        ###### `('they_are_different_node_than_us')`
        > Does the part we're hitting belong to a different bascenev1.Node?

        ##### Actions
        In a similar manner, actions are specified as tuples.
        Multiple actions can be specified by providing a tuple
        of tuples.

        ##### Available Actions
        ###### `('call', when, callable)`
        > Calls the provided callable;
        `when` can be either `'at_connect'` or `'at_disconnect'`.
        `'at_connect'` means to fire
        when the two parts first come in contact; `'at_disconnect'`
        means to fire once they cease being in contact.

        ###### `('message', who, when, message_obj)`
        > Sends a message object;
        `who` can be either `'our_node'` or `'their_node'`, `when` can be
        `'at_connect'` or `'at_disconnect'`, and `message_obj` is the message
        object to send.
        This has the same effect as calling the node's
        babase.Node.handlemessage() method.

        ###### `('modify_part_collision', attr, value)`
        > Changes some
        characteristic of the physical collision that will occur between
        our part and their part. This change will remain in effect as
        long as the two parts remain overlapping. This means if you have a
        part with a material that turns `'collide'` off against parts
        younger than 100ms, and it touches another part that is 50ms old,
        it will continue to not collide with that part until they separate,
        even if the 100ms threshold is passed. Options for attr/value are:
        `'physical'` (boolean value; whether a *physical* response will
        occur at all), `'friction'` (float value; how friction-y the
        physical response will be), `'collide'` (boolean value;
        whether *any* collision will occur at all, including non-physical
        stuff like callbacks), `'use_node_collide'`
        (boolean value; whether to honor modify_node_collision
        overrides for this collision), `'stiffness'` (float value,
        how springy the physical response is), `'damping'` (float
        value, how damped the physical response is), `'bounce'` (float
        value; how bouncy the physical response is).

        ###### `('modify_node_collision', attr, value)`
        > Similar to
        `modify_part_collision`, but operates at a node-level.
        collision attributes set here will remain in effect as long as
        *anything* from our part's node and their part's node overlap.
        A key use of this functionality is to prevent new nodes from
        colliding with each other if they appear overlapped;
        if `modify_part_collision` is used, only the individual
        parts that were overlapping would avoid contact, but other parts
        could still contact leaving the two nodes 'tangled up'. Using
        `modify_node_collision` ensures that the nodes must completely
        separate before they can start colliding. Currently the only attr
        available here is `'collide'` (a boolean value).

        ###### `('sound', sound, volume)`
        > Plays a bascenev1.Sound when a collision
        occurs, at a given volume, regardless of the collision speed/etc.

        ###### `('impact_sound', sound, targetImpulse, volume)`
        > Plays a sound
        when a collision occurs, based on the speed of impact.
        Provide a bascenev1.Sound, a target-impulse, and a volume.

        ###### `('skid_sound', sound, targetImpulse, volume)`
        > Plays a sound
        during a collision when parts are 'scraping' against each other.
        Provide a bascenev1.Sound, a target-impulse, and a volume.

        ###### `('roll_sound', sound, targetImpulse, volume)`
        > Plays a sound
        during a collision when parts are 'rolling' against each other.
        Provide a bascenev1.Sound, a target-impulse, and a volume.

        ##### Examples
        **Example 1:** create a material that lets us ignore
        collisions against any nodes we touch in the first
        100 ms of our existence; handy for preventing us from
        exploding outward if we spawn on top of another object:
        >>> m = bascenev1.Material()
        ... m.add_actions(
        ...     conditions=(('we_are_younger_than', 100),
        ...                 'or', ('they_are_younger_than', 100)),
        ...     actions=('modify_node_collision', 'collide', False))

        **Example 2:** send a bascenev1.DieMessage to anything we touch, but
        cause no physical response. This should cause any bascenev1.Actor to
        drop dead:
        >>> m = bascenev1.Material()
        ... m.add_actions(
        ...     actions=(('modify_part_collision', 'physical', False),
        ...              ('message', 'their_node', 'at_connect',
        ...                  bascenev1.DieMessage())))

        **Example 3:** play some sounds when we're contacting the ground:
        >>> m = bascenev1.Material()
        ... m.add_actions(
        ...     conditions=('they_have_material', shared.footing_material),
        ...     actions=(
                  ('impact_sound', bascenev1.getsound('metalHit'), 2, 5),
                  ('skid_sound', bascenev1.getsound('metalSkid'), 2, 5)))
        """
        return None


class Mesh:
    """A reference to a mesh.

    Category: **Asset Classes**

    Meshes are used for drawing.
    Use bascenev1.getmesh() to instantiate one.
    """

    pass


# noinspection PyShadowingBuiltins
class Node:
    """Reference to a Node; the low level building block of a game.

    Category: **Gameplay Classes**

    At its core, a game is nothing more than a scene of Nodes
    with attributes getting interconnected or set over time.

    A bascenev1.Node instance should be thought of as a weak-reference
    to a game node; *not* the node itself. This means a Node's
    lifecycle is completely independent of how many Python references
    to it exist. To explicitly add a new node to the game, use
    bascenev1.newnode(), and to explicitly delete one,
     use bascenev1.Node.delete().
    babase.Node.exists() can be used to determine if a Node still points
    to a live node in the game.

    You can use `ba.Node(None)` to instantiate an invalid
    Node reference (sometimes used as attr values/etc).
    """

    # Note attributes:
    # NOTE: I'm just adding *all* possible node attrs here
    # now now since we have a single bascenev1.Node type; in the
    # future I hope to create proper individual classes
    # corresponding to different node types with correct
    # attributes per node-type.
    color: Sequence[float] = (0.0, 0.0, 0.0)
    size: Sequence[float] = (0.0, 0.0, 0.0)
    position: Sequence[float] = (0.0, 0.0, 0.0)
    position_center: Sequence[float] = (0.0, 0.0, 0.0)
    position_forward: Sequence[float] = (0.0, 0.0, 0.0)
    punch_position: Sequence[float] = (0.0, 0.0, 0.0)
    punch_velocity: Sequence[float] = (0.0, 0.0, 0.0)
    velocity: Sequence[float] = (0.0, 0.0, 0.0)
    name_color: Sequence[float] = (0.0, 0.0, 0.0)
    tint_color: Sequence[float] = (0.0, 0.0, 0.0)
    tint2_color: Sequence[float] = (0.0, 0.0, 0.0)
    text: babase.Lstr | str = ''
    texture: bascenev1.Texture | None = None
    tint_texture: bascenev1.Texture | None = None
    times: Sequence[int] = (1, 2, 3, 4, 5)
    values: Sequence[float] = (1.0, 2.0, 3.0, 4.0)
    offset: float = 0.0
    input0: float = 0.0
    input1: float = 0.0
    input2: float = 0.0
    input3: float = 0.0
    flashing: bool = False
    scale: float | Sequence[float] = 0.0
    opacity: float = 0.0
    loop: bool = False
    time1: int = 0
    time2: int = 0
    timemax: int = 0
    client_only: bool = False
    materials: Sequence[bascenev1.Material] = ()
    roller_materials: Sequence[bascenev1.Material] = ()
    name: str = ''
    punch_materials: Sequence[bascenev1.Material] = ()
    pickup_materials: Sequence[bascenev1.Material] = ()
    extras_material: Sequence[bascenev1.Material] = ()
    rotate: float = 0.0
    hold_node: bascenev1.Node | None = None
    hold_body: int = 0
    host_only: bool = False
    premultiplied: bool = False
    source_player: bascenev1.Player | None = None
    mesh_opaque: bascenev1.Mesh | None = None
    mesh_transparent: bascenev1.Mesh | None = None
    damage_smoothed: float = 0.0
    gravity_scale: float = 1.0
    punch_power: float = 0.0
    punch_momentum_linear: Sequence[float] = (0.0, 0.0, 0.0)
    punch_momentum_angular: float = 0.0
    rate: int = 0
    vr_depth: float = 0.0
    is_area_of_interest: bool = False
    jump_pressed: bool = False
    pickup_pressed: bool = False
    punch_pressed: bool = False
    bomb_pressed: bool = False
    fly_pressed: bool = False
    hold_position_pressed: bool = False
    knockout: float = 0.0
    invincible: bool = False
    stick_to_owner: bool = False
    damage: int = 0
    run: float = 0.0
    move_up_down: float = 0.0
    move_left_right: float = 0.0
    curse_death_time: int = 0
    boxing_gloves: bool = False
    hockey: bool = False
    use_fixed_vr_overlay: bool = False
    allow_kick_idle_players: bool = False
    music_continuous: bool = False
    music_count: int = 0
    hurt: float = 0.0
    always_show_health_bar: bool = False
    mini_billboard_1_texture: bascenev1.Texture | None = None
    mini_billboard_1_start_time: int = 0
    mini_billboard_1_end_time: int = 0
    mini_billboard_2_texture: bascenev1.Texture | None = None
    mini_billboard_2_start_time: int = 0
    mini_billboard_2_end_time: int = 0
    mini_billboard_3_texture: bascenev1.Texture | None = None
    mini_billboard_3_start_time: int = 0
    mini_billboard_3_end_time: int = 0
    boxing_gloves_flashing: bool = False
    dead: bool = False
    floor_reflection: bool = False
    debris_friction: float = 0.0
    debris_kill_height: float = 0.0
    vr_near_clip: float = 0.0
    shadow_ortho: bool = False
    happy_thoughts_mode: bool = False
    shadow_offset: Sequence[float] = (0.0, 0.0)
    paused: bool = False
    time: int = 0
    ambient_color: Sequence[float] = (1.0, 1.0, 1.0)
    camera_mode: str = 'rotate'
    frozen: bool = False
    area_of_interest_bounds: Sequence[float] = (-1, -1, -1, 1, 1, 1)
    shadow_range: Sequence[float] = (0, 0, 0, 0)
    counter_text: str = ''
    counter_texture: bascenev1.Texture | None = None
    shattered: int = 0
    billboard_texture: bascenev1.Texture | None = None
    billboard_cross_out: bool = False
    billboard_opacity: float = 0.0
    slow_motion: bool = False
    music: str = ''
    vr_camera_offset: Sequence[float] = (0.0, 0.0, 0.0)
    vr_overlay_center: Sequence[float] = (0.0, 0.0, 0.0)
    vr_overlay_center_enabled: bool = False
    vignette_outer: Sequence[float] = (0.0, 0.0)
    vignette_inner: Sequence[float] = (0.0, 0.0)
    tint: Sequence[float] = (1.0, 1.0, 1.0)

    def __bool__(self) -> bool:
        """Support for bool evaluation."""
        return bool(True)  # Slight obfuscation.

    def add_death_action(self, action: Callable[[], None]) -> None:
        """Add a callable object to be called upon this node's death.
        Note that these actions are run just after the node dies, not before.
        """
        return None

    def changerotation(self, x: int, y: int, z: int) -> None:
        """added by smoothy"""
        return None

    def connectattr(self, srcattr: str, dstnode: Node, dstattr: str) -> None:
        """Connect one of this node's attributes to an attribute on another
        node. This will immediately set the target attribute's value to that
        of the source attribute, and will continue to do so once per step
        as long as the two nodes exist. The connection can be severed by
        setting the target attribute to any value or connecting another
        node attribute to it.

        ##### Example
        Create a locator and attach a light to it:
        >>> light = bascenev1.newnode('light')
        ... loc = bascenev1.newnode('locator', attrs={'position': (0, 10, 0)})
        ... loc.connectattr('position', light, 'position')
        """
        return None

    def delete(self, ignore_missing: bool = True) -> None:
        """Delete the node. Ignores already-deleted nodes if `ignore_missing`
        is True; otherwise a bascenev1.NodeNotFoundError is thrown.
        """
        return None

    def exists(self) -> bool:
        """Returns whether the Node still exists.
        Most functionality will fail on a nonexistent Node, so it's never a bad
        idea to check this.

        Note that you can also use the boolean operator for this same
        functionality, so a statement such as "if mynode" will do
        the right thing both for Node objects and values of None.
        """
        return bool()

    # Show that ur return type varies based on "doraise" value:
    @overload
    def getdelegate(
        self, type: type[_T], doraise: Literal[False] = False
    ) -> _T | None:
        ...

    @overload
    def getdelegate(self, type: type[_T], doraise: Literal[True]) -> _T:
        ...

    def getdelegate(self, type: Any, doraise: bool = False) -> Any:
        """Return the node's current delegate object if it matches
        a certain type.

        If the node has no delegate or it is not an instance of the passed
        type, then None will be returned. If 'doraise' is True, then an
        babase.DelegateNotFoundError will be raised instead.
        """
        return None

    def getname(self) -> str:
        """Return the name assigned to a Node; used mainly for debugging"""
        return str()

    def getnodetype(self) -> str:
        """Return the type of Node referenced by this object as a string.
        (Note this is different from the Python type which is always
         bascenev1.Node)
        """
        return str()

    def handlemessage(self, *args: Any) -> None:
        """General message handling; can be passed any message object.

        All standard message objects are forwarded along to the
        bascenev1.Node's delegate for handling (generally the bascenev1.Actor
        that made the node).

        bascenev1.Node-s are unique, however, in that they can be passed a
        second form of message; 'node-messages'.  These consist of a string
        type-name as a first argument along with the args specific to that type
        name as additional arguments.
        Node-messages communicate directly with the low-level node layer
        and are delivered simultaneously on all game clients,
        acting as an alternative to setting node attributes.
        """
        return None


class SessionData:
    """(internal)"""

    def context(self) -> bascenev1.ContextRef:
        """Return a context-ref pointing to the session."""
        import bascenev1  # pylint: disable=cyclic-import

        return bascenev1.ContextRef()

    def exists(self) -> bool:
        """Returns whether the SessionData still exists.
        Most functionality will fail on a nonexistent instance.
        """
        return bool()


# noinspection PyShadowingBuiltins
class SessionPlayer:
    """A reference to a player in the bascenev1.Session.

    Category: **Gameplay Classes**

    These are created and managed internally and
    provided to your bascenev1.Session/bascenev1.Activity instances.
    Be aware that, like `ba.Node`s, bascenev1.SessionPlayer objects are
    'weak' references under-the-hood; a player can leave the game at
     any point. For this reason, you should make judicious use of the
    babase.SessionPlayer.exists() method (or boolean operator) to ensure
    that a SessionPlayer is still present if retaining references to one
    for any length of time.
    """

    id: int
    """The unique numeric ID of the Player.

       Note that you can also use the boolean operator for this same
       functionality, so a statement such as "if player" will do
       the right thing both for Player objects and values of None."""

    in_game: bool
    """This bool value will be True once the Player has completed
       any lobby character/team selection."""

    sessionteam: bascenev1.SessionTeam
    """The bascenev1.SessionTeam this Player is on. If the
       SessionPlayer is still in its lobby selecting a team/etc.
       then a bascenev1.SessionTeamNotFoundError will be raised."""

    inputdevice: bascenev1.InputDevice
    """The input device associated with the player."""

    color: Sequence[float]
    """The base color for this Player.
       In team games this will match the bascenev1.SessionTeam's
       color."""

    highlight: Sequence[float]
    """A secondary color for this player.
       This is used for minor highlights and accents
       to allow a player to stand apart from his teammates
       who may all share the same team (primary) color."""

    character: str
    """The character this player has selected in their profile."""

    activityplayer: bascenev1.Player | None
    """The current game-specific instance for this player."""

    def __bool__(self) -> bool:
        """Support for bool evaluation."""
        return bool(True)  # Slight obfuscation.

    def assigninput(
        self,
        type: bascenev1.InputType | tuple[bascenev1.InputType, ...],
        call: Callable,
    ) -> None:
        """Set the python callable to be run for one or more types of input."""
        return None

    def exists(self) -> bool:
        """Return whether the underlying player is still in the game."""
        return bool()

    def get_icon(self) -> dict[str, Any]:
        """Returns the character's icon (images, colors, etc contained
        in a dict.
        """
        return {'foo': 'bar'}

    def get_icon_info(self) -> dict[str, Any]:
        """(internal)"""
        return {'foo': 'bar'}

    def get_v1_account_id(self) -> str:
        """Return the V1 Account ID this player is signed in under, if
        there is one and it can be determined with relative certainty.
        Returns None otherwise. Note that this may require an active
        internet connection (especially for network-connected players)
        and may return None for a short while after a player initially
        joins (while verification occurs).
        """
        return str()

    def getname(self, full: bool = False, icon: bool = True) -> str:
        """Returns the player's name. If icon is True, the long version of the
        name may include an icon.
        """
        return str()

    def remove_from_game(self) -> None:
        """Removes the player from the game."""
        return None

    def resetinput(self) -> None:
        """Clears out the player's assigned input actions."""
        return None

    def set_icon_info(
        self,
        texture: str,
        tint_texture: str,
        tint_color: Sequence[float],
        tint2_color: Sequence[float],
    ) -> None:
        """(internal)"""
        return None

    def setactivity(self, activity: bascenev1.Activity | None) -> None:
        """(internal)"""
        return None

    def setdata(
        self,
        team: bascenev1.SessionTeam,
        character: str,
        color: Sequence[float],
        highlight: Sequence[float],
    ) -> None:
        """(internal)"""
        return None

    def setname(
        self, name: str, full_name: str | None = None, real: bool = True
    ) -> None:
        """Set the player's name to the provided string.
        A number will automatically be appended if the name is not unique from
        other players.
        """
        return None

    def setnode(self, node: bascenev1.Node | None) -> None:
        """(internal)"""
        return None


class Sound:
    """A reference to a sound.

    Category: **Asset Classes**

    Use bascenev1.getsound() to instantiate one.
    """

    def play(
        self,
        volume: float = 1.0,
        position: Sequence[float] | None = None,
        host_only: bool = False,
    ) -> None:
        """Play the sound a single time.

        Category: **Gameplay Functions**

        If position is not provided, the sound will be at a constant volume
        everywhere. Position should be a float tuple of size 3.
        """
        return None


class Texture:
    """A reference to a texture.

    Category: **Asset Classes**

    Use bascenev1.gettexture() to instantiate one.
    """

    pass


# noinspection PyShadowingNames
class Timer:
    """Timers are used to run code at later points in time.

    Category: **General Utility Classes**

    This class encapsulates a scene-time timer in the current
    bascenev1.Context. The underlying timer will be destroyed when either
    this object is no longer referenced or when its Context (Activity,
    etc.) dies. If you do not want to worry about keeping a reference to
    your timer around,
    you should use the bs.timer() function instead.

    Scene time maps to local simulation time in bascenev1.Activity or
    bascenev1.Session Contexts. This means that it may progress slower
    in slow-motion play modes, stop when the game is paused, etc.

    ###### time
    > Length of time (in seconds by default) that the timer will wait
    before firing. Note that the actual delay experienced may vary
    depending on the timetype. (see below)

    ###### call
    > A callable Python object. Note that the timer will retain a
    strong reference to the callable for as long as it exists, so you
    may want to look into concepts such as babase.WeakCall if that is not
    desired.

    ###### repeat
    > If True, the timer will fire repeatedly, with each successive
    firing having the same delay as the first.

    ##### Example

    Use a Timer object to print repeatedly for a few seconds:
    >>> import bascenev1 as bs
    ... def say_it():
    ...     bs.screenmessage('BADGER!')
    ... def stop_saying_it():
    ...     global g_timer
    ...     g_timer = None
    ...     bs.screenmessage('MUSHROOM MUSHROOM!')
    ... # Create our timer; it will run as long as we have the self.t ref.
    ... g_timer = bs.Timer(0.3, say_it, repeat=True)
    ... # Now fire off a one-shot timer to kill it.
    ... bs.timer(3.89, stop_saying_it)
    """

    def __init__(
        self, time: float, call: Callable[[], Any], repeat: bool = False
    ) -> None:
        pass


def app_mode_activate() -> None:
    """(internal)"""
    return None


def app_mode_deactivate() -> None:
    """(internal)"""
    return None


def append_owner_ip(ip: str) -> None:
    """(internal)"""
    return None


def basetime() -> bascenev1.BaseTime:
    """Return the base-time in seconds for the current scene-v1 context.

    Category: **General Utility Functions**

    Base-time is a time value that progresses at a constant rate for a scene,
    even when the scene is sped up, slowed down, or paused. It may, however,
    speed up or slow down due to replay speed adjustments or may slow down
    if the cpu is overloaded.
    Note that the value returned here is simply a float; it just has a
    unique type in the type-checker's eyes to help prevent it from being
    accidentally used with time functionality expecting other time types.
    """
    import bascenev1  # pylint: disable=cyclic-import

    return bascenev1.BaseTime(0.0)


# noinspection PyShadowingNames
# noinspection PyShadowingBuiltins
def basetimer(
    time: float, call: Callable[[], Any], repeat: bool = False
) -> None:
    """Schedule a call to run at a later point in scene base-time.
    Base-time is a value that progresses at a constant rate for a scene,
     even when the scene is sped up, slowed down, or paused. It may,
     however, speed up or slow down due to replay speed adjustments or may
     slow down if the cpu is overloaded.

    Category: **General Utility Functions**

    This function adds a timer to the current scene context.
    This timer cannot be canceled or modified once created. If you
     require the ability to do so, use the bascenev1.BaseTimer class
     instead.

    ##### Arguments
    ###### time (float)
    > Length of time in seconds that the timer will wait before firing.

    ###### call (Callable[[], Any])
    > A callable Python object. Remember that the timer will retain a
    strong reference to the callable for the duration of the timer, so you
    may want to look into concepts such as babase.WeakCall if that is not
    desired.

    ###### repeat (bool)
    > If True, the timer will fire repeatedly, with each successive
    firing having the same delay as the first.

    ##### Examples
    Print some stuff through time:
    >>> import bascenev1 as bs
    >>> bs.screenmessage('hello from now!')
    >>> bs.basetimer(1.0, bs.Call(bs.screenmessage, 'hello from the future!'))
    >>> bs.basetimer(2.0, bs.Call(bs.screenmessage,
    ...                       'hello from the future 2!'))
    """
    return None


def broadcastmessage(
    message: str | babase.Lstr,
    color: Sequence[float] | None = None,
    top: bool = False,
    image: dict[str, Any] | None = None,
    log: bool = False,
    clients: Sequence[int] | None = None,
    transient: bool = False,
) -> None:
    """Broadcast a screen-message to clients in the current session.

    Category: **General Utility Functions**

    If 'top' is True, the message will go to the top message area.
    For 'top' messages, 'image' must be a dict containing 'texture'
    and 'tint_texture' textures and 'tint_color' and 'tint2_color'
    colors. This defines an icon to display alongside the message.
    If 'log' is True, the message will also be submitted to the log.
    'clients' can be a list of client-ids the message should be sent
    to, or None to specify that everyone should receive it.
    If 'transient' is True, the message will not be included in the
    game-stream and thus will not show up when viewing replays.
    Currently the 'clients' option only works for transient messages.
    """
    return None


def camerashake(intensity: float = 1.0) -> None:
    """Shake the camera.

    Category: **Gameplay Functions**

    Note that some cameras and/or platforms (such as VR) may not display
    camera-shake, so do not rely on this always being visible to the
    player as a gameplay cue.
    """
    return None


def capture_gamepad_input(call: Callable[[dict], None]) -> None:
    """(internal)

    Add a callable to be called for subsequent gamepad events.
    The method is passed a dict containing info about the event.
    """
    return None


def capture_keyboard_input(call: Callable[[dict], None]) -> None:
    """(internal)

    Add a callable to be called for subsequent keyboard-game-pad events.
    The method is passed a dict containing info about the event.
    """
    return None


def chatmessage(
    message: str | babase.Lstr,
    clients: Sequence[int] | None = None,
    sender_override: str | None = None,
) -> None:
    """(internal)"""
    return None


def client_info_query_response(token: str, response: Any) -> None:
    """(internal)"""
    return None


def connect_to_party(
    address: str, port: int | None = None, print_progress: bool = True
) -> None:
    """(internal)"""
    return None


def disable_kickvote(id: str) -> None:
    """(internal)id: pb-id who cant start a kick vote to anyone"""
    return None


def disconnect_client(client_id: int, ban_time: int = 300) -> bool:
    """(internal)"""
    return bool()


def disconnect_from_host() -> None:
    """(internal)

    Category: General Utility Functions
    """
    return None


def emitfx(
    position: Sequence[float],
    velocity: Sequence[float] | None = None,
    count: int = 10,
    scale: float = 1.0,
    spread: float = 1.0,
    chunk_type: str = 'rock',
    emit_type: str = 'chunks',
    tendril_type: str = 'smoke',
) -> None:
    """Emit particles, smoke, etc. into the fx sim layer.

    Category: **Gameplay Functions**

    The fx sim layer is a secondary dynamics simulation that runs in
    the background and just looks pretty; it does not affect gameplay.
    Note that the actual amount emitted may vary depending on graphics
    settings, exiting element counts, or other factors.
    """
    return None


def end_host_scanning() -> None:
    """(internal)

    Category: General Utility Functions
    """
    return None


def get_chat_messages() -> list[str]:
    """(internal)"""
    return ['blah', 'blah2']


def get_client_device_uuid(client_id: float) -> str:
    """(internal)"""
    return str()


def get_client_ip(client_id: float) -> str:
    """(internal)"""
    return str()


def get_client_ping(client_id: float) -> str:
    """(internal)"""
    return str()


def get_client_public_device_uuid(client_id: int) -> str | None:
    """(internal)

    Category: General Utility Functions

    Return a public device UUID for a client. If the client does not
    exist or is running a version older than 1.6.10, returns None.
    Public device UUID uniquely identifies the device the client is
    using in a semi-permanent way. The UUID value will change
    periodically with updates to the game or operating system.
    """
    return ''


def get_collision_info(*args: Any) -> Any:
    """Return collision related values

    Category: **Gameplay Functions**

    Returns a single collision value or tuple of values such as location,
    depth, nodes involved, etc. Only call this in the handler of a
    collision-triggered callback or message
    """
    return _uninferrable()


def get_configurable_game_pads() -> list:
    """(internal)

    Returns a list of the currently connected gamepads that can be
    configured.
    """
    return list()


def get_connection_to_host_info() -> dict:
    """(internal)"""
    return dict()


def get_foreground_host_activity() -> bascenev1.Activity | None:
    """(internal)

    Returns the bascenev1.Activity currently in the foreground,
    or None if there is none.
    """
    import bascenev1  # pylint: disable=cyclic-import

    return bascenev1.Activity(settings={})


def get_foreground_host_session() -> bascenev1.Session | None:
    """(internal)

    Return the bascenev1.Session currently being displayed, or None if there is
    none.
    """
    import bascenev1  # pylint: disable=cyclic-import

    return bascenev1.Session([])


def get_game_port() -> int:
    """(internal)

    Return the port ballistica is hosting on.
    """
    return int()


def get_game_roster() -> list[dict[str, Any]]:
    """(internal)"""
    return [{'foo': 'bar'}]


def get_local_active_input_devices_count() -> int:
    """(internal)"""
    return int()


def get_package_collision_mesh(
    package: bascenev1.AssetPackage, name: str
) -> bascenev1.CollisionMesh:
    """(internal)"""
    import bascenev1  # pylint: disable=cyclic-import

    return bascenev1.CollisionMesh()


def get_package_data(
    package: bascenev1.AssetPackage, name: str
) -> bascenev1.Data:
    """(internal)."""
    import bascenev1  # pylint: disable=cyclic-import

    return bascenev1.Data()


def get_package_mesh(
    package: bascenev1.AssetPackage, name: str
) -> bascenev1.Mesh:
    """(internal)"""
    import bascenev1  # pylint: disable=cyclic-import

    return bascenev1.Mesh()


def get_package_sound(
    package: bascenev1.AssetPackage, name: str
) -> bascenev1.Sound:
    """(internal)."""
    import bascenev1  # pylint: disable=cyclic-import

    return bascenev1.Sound()


def get_package_texture(
    package: bascenev1.AssetPackage, name: str
) -> bascenev1.Texture:
    """(internal)"""
    import bascenev1  # pylint: disable=cyclic-import

    return bascenev1.Texture()


def get_public_party_enabled() -> bool:
    """(internal)"""
    return bool()


def get_public_party_max_size() -> int:
    """(internal)"""
    return int()


def get_random_names() -> list:
    """(internal)

    Returns the random names used by the game.
    """
    return list()


def get_replay_speed_exponent() -> int:
    """(internal)

    Returns current replay speed value. Actual displayed speed is pow(2,speed).
    """
    return int()


def get_ui_input_device() -> bascenev1.InputDevice | None:
    """(internal)

    Returns the input-device that currently owns the user interface, or
    None if there is none.
    """
    return InputDevice()


# Show that our return type varies based on "doraise" value:
@overload
def getactivity(doraise: Literal[True] = True) -> bascenev1.Activity:
    ...


@overload
def getactivity(doraise: Literal[False]) -> bascenev1.Activity | None:
    ...


def getactivity(doraise: bool = True) -> bascenev1.Activity | None:
    """Return the current bascenev1.Activity instance.

    Category: **Gameplay Functions**

    Note that this is based on context_ref; thus code run in a timer
    generated in Activity 'foo' will properly return 'foo' here, even if
    another Activity has since been created or is transitioning in.
    If there is no current Activity, raises a babase.ActivityNotFoundError.
    If doraise is False, None will be returned instead in that case.
    """
    return None


def getcollisionmesh(name: str) -> bascenev1.CollisionMesh:
    """Return a collision-mesh, loading it if necessary.

    Category: **Asset Functions**

    Collision-meshes are used in physics calculations for such things as
    terrain.

    Note that this function returns immediately even if the asset has yet
    to be loaded. To avoid hitches, instantiate your asset objects in
    advance of when you will be using them, allowing time for them to
    load in the background if necessary.
    """
    import bascenev1  # pylint: disable=cyclic-import

    return bascenev1.CollisionMesh()


def getdata(name: str) -> bascenev1.Data:
    """Return a data, loading it if necessary.

    Category: **Asset Functions**

    Note that this function returns immediately even if the asset has yet
    to be loaded. To avoid hitches, instantiate your asset objects in
    advance of when you will be using them, allowing time for them to
    load in the background if necessary.
    """
    import bascenev1  # pylint: disable=cyclic-import

    return bascenev1.Data()


# Show that our return type varies based on "doraise" value:
@overload
def getinputdevice(
    name: str, unique_id: str, doraise: Literal[True] = True
) -> bascenev1.InputDevice:
    ...


@overload
def getinputdevice(
    name: str, unique_id: str, doraise: Literal[False]
) -> bascenev1.InputDevice | None:
    ...


def getinputdevice(name: str, unique_id: str, doraise: bool = True) -> Any:
    """(internal)

    Given a type name and a unique identifier, returns an InputDevice.
    Throws an Exception if the input-device is not found, or returns None
    if 'doraise' is False.
    """
    return None


def getmesh(name: str) -> bascenev1.Mesh:
    """Return a mesh, loading it if necessary.

    Category: **Asset Functions**

    Note that this function returns immediately even if the asset has yet
    to be loaded. To avoid hitches, instantiate your asset objects in
    advance of when you will be using them, allowing time for them to
     load in the background if necessary.
    """
    import bascenev1  # pylint: disable=cyclic-import

    return bascenev1.Mesh()


def getnodes() -> list:
    """Return all nodes in the current bascenev1.Context.

    Category: **Gameplay Functions**
    """
    return list()


# Show that our return type varies based on "doraise" value:
@overload
def getsession(doraise: Literal[True] = True) -> bascenev1.Session:
    ...


@overload
def getsession(doraise: Literal[False]) -> bascenev1.Session | None:
    ...


def getsession(doraise: bool = True) -> bascenev1.Session | None:
    """Category: **Gameplay Functions**

    Returns the current bascenev1.Session instance.
    Note that this is based on context_ref; thus code being run in the UI
    context will return the UI context_ref here even if a game Session also
    exists, etc. If there is no current Session, an Exception is raised, or
    if doraise is False then None is returned instead.
    """
    return None


def getsound(name: str) -> bascenev1.Sound:
    """Return a sound, loading it if necessary.

    Category: **Asset Functions**

    Note that this function returns immediately even if the asset has yet
    to be loaded. To avoid hitches, instantiate your asset objects in
    advance of when you will be using them, allowing time for them to
    load in the background if necessary.
    """
    import bascenev1  # pylint: disable=cyclic-import

    return bascenev1.Sound()


def gettexture(name: str) -> bascenev1.Texture:
    """Return a texture, loading it if necessary.

    Category: **Asset Functions**

    Note that this function returns immediately even if the asset has yet
    to be loaded. To avoid hitches, instantiate your asset objects in
    advance of when you will be using them, allowing time for them to
    load in the background if necessary.
    """
    import bascenev1  # pylint: disable=cyclic-import

    return bascenev1.Texture()


def handle_app_intent_default() -> None:
    """(internal)"""
    return None


def handle_app_intent_exec(command: str) -> None:
    """(internal)"""
    return None


def have_connected_clients() -> bool:
    """(internal)

    Category: General Utility Functions
    """
    return bool()


def have_touchscreen_input() -> bool:
    """(internal)

    Returns whether or not a touch-screen input is present
    """
    return bool()


def hide_player_device_id(type: bool) -> None:
    """(internal)hide player device spec from roster to clients"""
    return None


def host_scan_cycle() -> list:
    """(internal)"""
    return list()


def is_in_replay() -> bool:
    """(internal)"""
    return bool()


def ls_input_devices() -> None:
    """Print debugging info about game objects.

    Category: **General Utility Functions**

    This call only functions in debug builds of the game.
    It prints various info about the current object count, etc.
    """
    return None


def ls_objects() -> None:
    """Log debugging info about C++ level objects.

    Category: **General Utility Functions**

    This call only functions in debug builds of the game.
    It prints various info about the current object count, etc.
    """
    return None


def new_host_session(
    sessiontype: type[bascenev1.Session], benchmark_type: str | None = None
) -> None:
    """(internal)"""
    return None


def new_replay_session(file_name: str) -> None:
    """(internal)"""
    return None


def newactivity(
    activity_type: type[bascenev1.Activity], settings: dict | None = None
) -> bascenev1.Activity:
    """Instantiates a bascenev1.Activity given a type object.

    Category: **General Utility Functions**

    Activities require special setup and thus cannot be directly
    instantiated; you must go through this function.
    """
    import bascenev1  # pylint: disable=cyclic-import

    return bascenev1.Activity(settings={})


# noinspection PyShadowingBuiltins
def newnode(
    type: str,
    owner: bascenev1.Node | None = None,
    attrs: dict | None = None,
    name: str | None = None,
    delegate: Any = None,
) -> bascenev1.Node:
    """Add a node of the given type to the game.

    Category: **Gameplay Functions**

    If a dict is provided for 'attributes', the node's initial attributes
    will be set based on them.

    'name', if provided, will be stored with the node purely for debugging
    purposes. If no name is provided, an automatic one will be generated
    such as 'terrain@foo.py:30'.

    If 'delegate' is provided, Python messages sent to the node will go to
    that object's handlemessage() method. Note that the delegate is stored
    as a weak-ref, so the node itself will not keep the object alive.

    if 'owner' is provided, the node will be automatically killed when that
    object dies. 'owner' can be another node or a bascenev1.Actor
    """
    import bascenev1  # pylint: disable=cyclic-import

    return bascenev1.Node()


def printnodes() -> None:
    """Print various info about existing nodes; useful for debugging.

    Category: **Gameplay Functions**
    """
    return None


def register_activity(activity: bascenev1.Activity) -> bascenev1.ActivityData:
    """(internal)"""
    import bascenev1  # pylint: disable=cyclic-import

    return bascenev1.ActivityData()


def register_session(session: bascenev1.Session) -> bascenev1.SessionData:
    """(internal)"""
    import bascenev1  # pylint: disable=cyclic-import

    return bascenev1.SessionData()


def release_gamepad_input() -> None:
    """(internal)

    Resumes normal gamepad event processing.
    """
    return None


def release_keyboard_input() -> None:
    """(internal)

    Resumes normal keyboard event processing.
    """
    return None


def reset_random_player_names() -> None:
    """(internal)"""
    return None


def set_admins(admins: list[str]) -> None:
    """(internal)"""
    return None


def set_authenticate_clients(enable: bool) -> None:
    """(internal)"""
    return None


def set_debug_speed_exponent(speed: int) -> None:
    """(internal)

    Sets the debug speed scale for the game. Actual speed is pow(2,speed).
    """
    return None


def set_enable_default_kick_voting(enable: bool) -> None:
    """(internal)"""
    return None


def set_game_speed(speed: int) -> None:
    """(internal)

    Sets the speed scale for the game.
    """
    return None


def set_internal_music(
    music: babase.SimpleSound | None, volume: float = 1.0, loop: bool = True
) -> None:
    """(internal)."""
    return None


def set_kickvote_msg_type(name: str) -> None:
    """(internal)set chat to show msg in chat"""
    return None


def set_map_bounds(
    bounds: tuple[float, float, float, float, float, float]
) -> None:
    """(internal)

    Set map bounds. Generally nodes that go outside of this box are killed.
    """
    return None


def set_master_server_source(source: int) -> None:
    """(internal)"""
    return None


def set_public_party_enabled(enabled: bool) -> None:
    """(internal)"""
    return None


def set_public_party_max_size(max_size: int) -> None:
    """(internal)"""
    return None


def set_public_party_name(name: str) -> None:
    """(internal)"""
    return None


def set_public_party_queue_enabled(max_size: bool) -> None:
    """(internal)"""
    return None


def set_public_party_stats_url(url: str | None) -> None:
    """(internal)"""
    return None


def set_replay_speed_exponent(speed: int) -> None:
    """(internal)

    Set replay speed. Actual displayed speed is pow(2, speed).
    """
    return None


def set_server_name(name: str) -> None:
    """(internal)set the host  name"""
    return None


def set_touchscreen_editing(editing: bool) -> None:
    """(internal)"""
    return None


def set_transparent_kickvote(type: bool) -> None:
    """(internal)True to show kick vote starter name"""
    return None


def time() -> bascenev1.Time:
    """Return the current scene time in seconds.

    Category: **General Utility Functions**

    Scene time maps to local simulation time in bascenev1.Activity or
    bascenev1.Session Contexts. This means that it may progress slower
    in slow-motion play modes, stop when the game is paused, etc.

    Note that the value returned here is simply a float; it just has a
    unique type in the type-checker's eyes to help prevent it from being
    accidentally used with time functionality expecting other time types.
    """
    import bascenev1  # pylint: disable=cyclic-import

    return bascenev1.Time(0.0)


# noinspection PyShadowingNames
def timer(time: float, call: Callable[[], Any], repeat: bool = False) -> None:
    """Schedule a call to run at a later point in time.

    Category: **General Utility Functions**

    This function adds a scene-time timer to the current babase.Context.
    This timer cannot be canceled or modified once created. If you
     require the ability to do so, use the babase.Timer class instead.

    Scene time maps to local simulation time in bascenev1.Activity or
    bascenev1.Session Contexts. This means that it may progress slower
    in slow-motion play modes, stop when the game is paused, etc.

    ##### Arguments
    ###### time (float)
    > Length of scene time in seconds that the timer will wait
    before firing.

    ###### call (Callable[[], Any])
    > A callable Python object. Note that the timer will retain a
    strong reference to the callable for as long as it exists, so you
    may want to look into concepts such as babase.WeakCall if that is not
    desired.

    ###### repeat (bool)
    > If True, the timer will fire repeatedly, with each successive
    firing having the same delay as the first.

    ##### Examples
    Print some stuff through time:
    >>> import bascenev1 as bs
    >>> bs.screenmessage('hello from now!')
    >>> bs.timer(1.0, bs.Call(bs.screenmessage, 'hello from the future!'))
    >>> bs.timer(2.0, bs.Call(bs.screenmessage,
    ...                       'hello from the future 2!'))
    """
    return None
